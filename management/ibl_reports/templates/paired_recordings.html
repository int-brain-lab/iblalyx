<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>

        body {
            height: 100vh;
        }
        .container
            {
            position: relative;
            width: 90%;
            overflow: auto;
            }

    </style>

<script src="http://d3js.org/d3.v7.min.js" charset="utf-8"></script>

</head>
<body>

    <div class="container">
    </div>

<script>

    // Pass in json data
     d3.json("{% url "paired" %}").then( function(data) {

        // PREPARE DATA

        // TODO maybe think of a more flexible format
        // Prepare the data into the formats that we need
        var matrix = [];
        var nodes = data.nodes;
        var n = nodes.length;

        // Create an empty matrix with size n x n
        // Each element has the following format {x: 0, y: 1, z: 0},
        // where x and y indicate the element location and z the value to be assigned to that element
        nodes.forEach(function(node, i) {
            node.index = i;
            node.count = 0;
            matrix[i] = d3.range(n).map(function(j) { return {x: j, y: i, z: 0}; });
          });

        // Fill the matrix with the values we have in data
        data.links.forEach(function(link) {
            matrix[link.source][link.target].z += link.value;
            matrix[link.target][link.source].z += link.value;
            matrix[link.source][link.source].z += link.value;
            matrix[link.target][link.target].z += link.value;
            nodes[link.source].count += link.value;
            nodes[link.target].count += link.value;
          });


        // Get out the names for each row / column of matrix
        var names = nodes.map(node => node.name);


        // CREATE AXIS

        var margin = {top: 50, bottom: 50, left: 50, right: 0};
        var width = Math.max(2 * names.length, 900)
        var height = Math.max(2 * names.length, 900)


        // Create scale band ranges for x and y axis
        var x = d3.scaleBand().domain(names).range([0, width]);
        var y = d3.scaleBand().domain(names).range([0, height]);
        // Crate linear scale range for z (color of each pixel)
        var z = d3.scaleLinear().domain([0, 10]).clamp(true);

        // Create axis objects and assign them the scales
        const xAxis = d3.axisTop(x);
        const yAxis = d3.axisLeft(y);

        // ADD ELEMENTS TO THE CONTAINER
        // Add a main svg element to our container
        const mainSvg = d3.select(".container").append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)

        // Add a group that will contain all our elements
        const svg = mainSvg.append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
          .call(zoom)

        // Define a clip path for the x axis (objects outside this clip path are masked)
        const xClipPath = mainSvg.append('clipPath')
          .attr('id', 'x-clip-path')
          .append('rect')
          .attr('x',0)
          .attr('y', -margin.top)
          .attr('width', width)
          .attr('height', margin.top);

        // Create a group for the x axis and add the clip path and also the axis
        const xAxisCont= svg.append("g")
          .attr("clip-path", 'url(#x-clip-path)')
          .append("g")
          .attr("class", "x-axis")
          .attr("transform", `translate(0,0)`)
          .call(xAxis);

        // Do the same for the y axis
        const yClipPath = mainSvg.append('clipPath')
          .attr('id', 'y-clip-path')
          .append('rect')
          .attr('x', -margin.left)
          .attr('y', 0)
          .attr('width', margin.left)
          .attr('height', height);

        var yaxisCont= svg.append("g")
          .attr("clip-path", 'url(#y-clip-path)')
          .append("g")
          .attr("class", "y-axis")
          .attr("transform", `translate(0,0)`)
          .call(yAxis);

        // Define a clip path for the data display
          const viewClipPath = mainSvg.append('clipPath')
          .attr('id', 'view-clip-path')
          .append('rect')
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', width)
          .attr('height', height);

        // Add the group for the data display and assign the clip path
        var viewCont= svg.append("g")
        .attr("clip-path", 'url(#view-clip-path)')

        // Add the group that will hold out data
        var view = viewCont.append("g")
          .attr("id", "view")

        // Add all the data to the view display
        var row = view.selectAll(".row")
        .data(matrix)
        .enter().append("g")
        .attr("class", "row")
        .attr("transform", function(d, i) {
          return "translate(0," + x(names[i]) + ")"; })
        .each(row);

        function row(row) {
            var cell = d3.select(this).selectAll(".cell")
                .data(row.filter(function(d) { return d.z; }))
                .enter().append("rect")
                .attr("class", "cell")
                .attr("x", function(d) { return x(names[d.x]); })
                .attr("y", 0)
                .attr("width", x.bandwidth())
                .attr("height", x.bandwidth())
                .style("fill-opacity", function(d) { return z(d.z); })
                .style("fill", function(d) { return nodes[d.x].color == nodes[d.y].color ? nodes[d.x].color : "grey"; })
          }


        // Zoom call back function
        function zoom(svg) {
            const extent = [[0, 0], [width, height]];
            svg.call(d3.zoom()
            .scaleExtent([1, 100])
            .translateExtent(extent)
            .extent(extent)
            .on("end", zoomed));
        }

        function zoomed(event) {

            view.attr("transform", event.transform);
            x.range([0, width * event.transform.k].map(d => event.transform.applyX(d)));
            y.range([0, height * event.transform.k].map(d => event.transform.applyY(d)));
            svg.selectAll(".x-axis").call(xAxis);
            svg.selectAll(".y-axis").call(yAxis);
        }

    });
</script>

</body>
</html>